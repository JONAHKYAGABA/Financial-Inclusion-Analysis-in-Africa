# -*- coding: utf-8 -*-
"""Financial Inclusion Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SqaU5MmuMoND9NP5wBLGlkKJuFoTBhKU
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# 
# !pip install geopandas folium

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import warnings
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import statsmodels.api as sm
from scipy import stats
import missingno as msno
from IPython.display import display, HTML

# Set style parameters
plt.style.use('seaborn-v0_8-whitegrid')
warnings.filterwarnings('ignore')
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', 100)

DATA_PATH = '/content/drive/MyDrive/Inclusivity/My data/'

def print_header(title):
    display(HTML(f"<h2>{title}</h2>"))

def load_and_examine_file(filepath, sheet_name=0):
    """Load file and provide basic information about it."""
    print(f"Loading: {filepath.split('/')[-1]}")

    try:
        if filepath.endswith('.csv'):
            try:
                df = pd.read_csv(filepath)
            except UnicodeDecodeError:
                # Try with different encoding if utf-8 fails
                df = pd.read_csv(filepath, encoding='latin1')
        elif filepath.endswith(('.xls', '.xlsx')):
            df = pd.read_excel(filepath, sheet_name=sheet_name)
        else:
            print(f"Unsupported file format: {filepath}")
            return None

        print(f"✓ Successfully loaded with shape: {df.shape}")
        return df

    except Exception as e:
        print(f"✗ Error loading file: {str(e)}")
        return None

def analyze_dataframe(df, name):
    """Analyze a dataframe and print key information."""
    print_header(f"Analysis of {name}")

    print(f"DataFrame shape: {df.shape} (rows, columns)")

    # Display first few rows
    print("\nSample data:")
    display(df.head())

    # Check for missing values
    missing = df.isnull().sum()
    missing_percent = (missing / len(df)) * 100
    missing_info = pd.DataFrame({
        'Missing Values': missing,
        'Percent Missing': missing_percent
    })
    print("\nMissing values:")
    display(missing_info[missing_info['Missing Values'] > 0])

    # Visualize missing values
    if missing.sum() > 0:
        plt.figure(figsize=(10, 6))
        msno.matrix(df)
        plt.title(f'Missing Value Patterns in {name}')
        plt.tight_layout()
        plt.show()

    # Dataframe info
    print("\nColumn info:")
    df.info()

    # For numerical columns, show summary statistics
    num_cols = df.select_dtypes(include=['int64', 'float64']).columns
    if len(num_cols) > 0:
        print("\nNumerical column statistics:")
        display(df[num_cols].describe())

    # For categorical columns, show value counts
    cat_cols = df.select_dtypes(include=['object', 'category']).columns
    if len(cat_cols) > 0:
        print("\nCategorical column information:")
        for col in cat_cols[:min(5, len(cat_cols))]:  # Show first 5 only to avoid clutter
            print(f"\nValue counts for {col}:")
            display(df[col].value_counts().head(10))

    return df

def visualize_categorical_column(df, column, title=None, figsize=(10, 6)):
    """Visualize a categorical column with a bar chart."""
    plt.figure(figsize=figsize)

    if df[column].nunique() > 10:
        top_n = df[column].value_counts().head(10)
        sns.barplot(x=top_n.index, y=top_n.values)
        plt.title(f'Top 10 values for {title or column}')
    else:
        sns.countplot(y=column, data=df, order=df[column].value_counts().index)
        plt.title(f'Distribution of {title or column}')

    plt.tight_layout()
    plt.show()

def visualize_numerical_column(df, column, title=None, bins=30, figsize=(10, 6)):
    """Visualize a numerical column with histograms and box plots."""
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=figsize)

    # Histogram
    sns.histplot(df[column].dropna(), bins=bins, kde=True, ax=ax1)
    ax1.set_title(f'Distribution of {title or column}')

    # Box plot
    sns.boxplot(x=df[column].dropna(), ax=ax2)
    ax2.set_title(f'Box plot of {title or column}')

    plt.tight_layout()
    plt.show()

    # Print summary statistics
    print(f"Summary statistics for {column}:")
    display(df[column].describe())

def create_correlation_heatmap(df, cols=None, method='pearson', title="Correlation Matrix", figsize=(12, 10)):
    """Create a correlation heatmap for the given columns."""
    if cols is None:
        # Use all numeric columns
        cols = df.select_dtypes(include=['int64', 'float64']).columns

    corr = df[cols].corr(method=method)

    plt.figure(figsize=figsize)
    mask = np.triu(np.ones_like(corr, dtype=bool))

    # Generate a custom diverging colormap
    cmap = sns.diverging_palette(230, 20, as_cmap=True)

    # Draw the heatmap
    sns.heatmap(corr, mask=mask, cmap=cmap, vmax=1, vmin=-1, center=0,
                square=True, linewidths=.5, annot=True, fmt=".2f", annot_kws={"size": 8})

    plt.title(title, fontsize=16)
    plt.xticks(rotation=45, ha='right', fontsize=10)
    plt.yticks(fontsize=10)
    plt.tight_layout()
    plt.show()

    return corr

databank_df = load_and_examine_file(f"{DATA_PATH}DatabankWide (1).xlsx")
databank_df = analyze_dataframe(databank_df, "Global Financial Inclusion Databank")

mobile_money_df = load_and_examine_file(f"{DATA_PATH}Global_Mobile_Money_Dataset_2023 (1).xlsx")
mobile_money_df = analyze_dataframe(mobile_money_df, "Global Mobile Money Dataset")

fi_indicators_df = load_and_examine_file(f"{DATA_PATH}BoU/FI-Indicators-Dec-2024.xlsx")
fi_indicators_df = analyze_dataframe(fi_indicators_df, "Financial Inclusion Indicators")

# Agent and end-user datasets for mobile money
agent_demographics_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/agent_demographics.csv")
agent_demographics_df = analyze_dataframe(agent_demographics_df, "Agent Demographics")

end_user_demographics_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/end_user_demographics.csv")
end_user_demographics_df = analyze_dataframe(end_user_demographics_df, "End User Demographics")

mobile_money_stats_df = load_and_examine_file(f"{DATA_PATH}BoU/Mobile-Money-Stats-W.xlsx")
mobile_money_stats_df = analyze_dataframe(mobile_money_stats_df, "Mobile Money Statistics")

cross_network_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/cross_network_transactions.csv")
cross_network_df = analyze_dataframe(cross_network_df, "Cross Network Transactions")

# Let's focus on Uganda if possible
uganda_data = None
try:
    if 'Country name' in databank_df.columns:
        uganda_data = databank_df[databank_df['Country name'] == 'Uganda'].copy()
        print(f"✓ Found Uganda data with {uganda_data.shape[0]} rows")

        # Display Uganda data over time
        if 'Year' in uganda_data.columns:
            print("\nUganda financial inclusion trends over time:")
            display(uganda_data.sort_values('Year'))
    else:
        print("No country name column found in databank dataset")
except Exception as e:
    print(f"Error filtering Uganda data: {str(e)}")

if uganda_data is not None and len(uganda_data) > 0:
    try:
        # Set up time series plot for account ownership
        plt.figure(figsize=(14, 8))

        # Plot key metrics over time
        key_metrics = [
            'Account (% age 15+)',
            'Mobile money account (% age 15+)',
            'Financial institution account (% age 15+)',
            'Made or received a digital payment (% age 15+)'
        ]

        for metric in key_metrics:
            if metric in uganda_data.columns:
                plt.plot(uganda_data['Year'], uganda_data[metric], marker='o', linewidth=2, label=metric)

        plt.title('Financial Inclusion Trends in Uganda', fontsize=16)
        plt.xlabel('Year', fontsize=12)
        plt.ylabel('Percentage (%)', fontsize=12)
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.tight_layout()
        plt.show()

        # Compare mobile money vs traditional banking
        plt.figure(figsize=(12, 7))

        compare_metrics = [
            ('Mobile money account (% age 15+)', 'Mobile Money'),
            ('Financial institution account (% age 15+)', 'Traditional Banking')
        ]

        for metric, label in compare_metrics:
            if metric in uganda_data.columns:
                plt.plot(uganda_data['Year'], uganda_data[metric], marker='o', linewidth=2, label=label)

        plt.title('Mobile Money vs Traditional Banking Adoption in Uganda', fontsize=16)
        plt.xlabel('Year', fontsize=12)
        plt.ylabel('Percentage (%)', fontsize=12)
        plt.grid(True, alpha=0.3)
        plt.legend()
        plt.tight_layout()
        plt.show()

    except Exception as e:
        print(f"Error creating time series plots: {str(e)}")

try:
    if 'Account, female (% age 15+)' in databank_df.columns and 'Account, male (% age 15+)' in databank_df.columns:
        # Get the most recent year data for Uganda
        if uganda_data is not None and len(uganda_data) > 0:
            recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

            # Gender comparison
            gender_metrics = [
                ('Account', 'Account, female (% age 15+)', 'Account, male (% age 15+)'),
                ('Financial institution account', 'Financial institution account, female (% age 15+)', 'Financial institution account, male (% age 15+)'),
                ('Mobile money account', 'Mobile money account, female (% age 15+)', 'Mobile money account, male (% age 15+)'),
                ('Made or received a digital payment', 'Made or received a digital payment, female (% age 15+)', 'Made or received a digital payment, male (% age 15+)'),
                ('Saved any money', 'Saved any money, female (% age 15+)', 'Saved any money, male (% age 15+)'),
                ('Borrowed any money', 'Borrowed any money, female (% age 15+)', 'Borrowed any money, male (% age 15+)')
            ]

            # Create data for plotting
            categories = []
            female_values = []
            male_values = []

            for category, female_col, male_col in gender_metrics:
                if female_col in recent_data and male_col in recent_data:
                    categories.append(category)
                    female_values.append(recent_data[female_col])
                    male_values.append(recent_data[male_col])

            # Plot the gender comparison
            if categories:
                plt.figure(figsize=(12, 8))

                x = np.arange(len(categories))
                width = 0.35

                plt.bar(x - width/2, female_values, width, label='Female')
                plt.bar(x + width/2, male_values, width, label='Male')

                plt.xlabel('Financial Inclusion Category')
                plt.ylabel('Percentage (%)')
                plt.title('Gender Comparison of Financial Inclusion Metrics')
                plt.xticks(x, categories, rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()

                # Calculate and display gender gaps
                gender_gap = pd.DataFrame({
                    'Category': categories,
                    'Female (%)': female_values,
                    'Male (%)': male_values,
                    'Gender Gap (M-F)': [m - f for m, f in zip(male_values, female_values)]
                })

                print("Gender gap analysis in financial inclusion:")
                display(gender_gap.sort_values('Gender Gap (M-F)', ascending=False))

    # Urban vs Rural comparison if data available
    if 'Account, rural (% age 15+)' in databank_df.columns and 'Account, urban (% age 15+)' in databank_df.columns:
        # Similar analysis for urban/rural
        if uganda_data is not None and len(uganda_data) > 0:
            recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

            location_metrics = [
                ('Account', 'Account, rural (% age 15+)', 'Account, urban (% age 15+)'),
                ('Financial institution account', 'Financial institution account, rural (% age 15+)', 'Financial institution account, urban (% age 15+)'),
                ('Mobile money account', 'Mobile money account, rural (% age 15+)', 'Mobile money account, urban (% age 15+)'),
                ('Made or received a digital payment', 'Made or received a digital payment, rural (% age 15+)', 'Made or received a digital payment, urban (% age 15+)'),
                ('Saved any money', 'Saved any money, rural (% age 15+)', 'Saved any money, urban (% age 15+)'),
                ('Borrowed any money', 'Borrowed any money, rural (% age 15+)', 'Borrowed any money, urban (% age 15+)')
            ]

            # Create data for plotting
            categories = []
            rural_values = []
            urban_values = []

            for category, rural_col, urban_col in location_metrics:
                if rural_col in recent_data and urban_col in recent_data:
                    categories.append(category)
                    rural_values.append(recent_data[rural_col])
                    urban_values.append(recent_data[urban_col])

            # Plot the urban/rural comparison
            if categories:
                plt.figure(figsize=(12, 8))

                x = np.arange(len(categories))
                width = 0.35

                plt.bar(x - width/2, rural_values, width, label='Rural')
                plt.bar(x + width/2, urban_values, width, label='Urban')

                plt.xlabel('Financial Inclusion Category')
                plt.ylabel('Percentage (%)')
                plt.title('Urban vs Rural Comparison of Financial Inclusion Metrics')
                plt.xticks(x, categories, rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()

                # Calculate and display urban-rural gaps
                location_gap = pd.DataFrame({
                    'Category': categories,
                    'Rural (%)': rural_values,
                    'Urban (%)': urban_values,
                    'Urban-Rural Gap': [u - r for u, r in zip(urban_values, rural_values)]
                })

                print("Urban-Rural gap analysis in financial inclusion:")
                display(location_gap.sort_values('Urban-Rural Gap', ascending=False))

except Exception as e:
    print(f"Error in demographic analysis: {str(e)}")

try:
    if 'Account, female (% age 15+)' in databank_df.columns and 'Account, male (% age 15+)' in databank_df.columns:
        # Get the most recent year data for Uganda
        if uganda_data is not None and len(uganda_data) > 0:
            recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

            # Gender comparison
            gender_metrics = [
                ('Account', 'Account, female (% age 15+)', 'Account, male (% age 15+)'),
                ('Financial institution account', 'Financial institution account, female (% age 15+)', 'Financial institution account, male (% age 15+)'),
                ('Mobile money account', 'Mobile money account, female (% age 15+)', 'Mobile money account, male (% age 15+)'),
                ('Made or received a digital payment', 'Made or received a digital payment, female (% age 15+)', 'Made or received a digital payment, male (% age 15+)'),
                ('Saved any money', 'Saved any money, female (% age 15+)', 'Saved any money, male (% age 15+)'),
                ('Borrowed any money', 'Borrowed any money, female (% age 15+)', 'Borrowed any money, male (% age 15+)')
            ]

            # Create data for plotting
            categories = []
            female_values = []
            male_values = []

            for category, female_col, male_col in gender_metrics:
                if female_col in recent_data and male_col in recent_data:
                    categories.append(category)
                    female_values.append(recent_data[female_col])
                    male_values.append(recent_data[male_col])

            # Plot the gender comparison
            if categories:
                plt.figure(figsize=(12, 8))

                x = np.arange(len(categories))
                width = 0.35

                plt.bar(x - width/2, female_values, width, label='Female')
                plt.bar(x + width/2, male_values, width, label='Male')

                plt.xlabel('Financial Inclusion Category')
                plt.ylabel('Percentage (%)')
                plt.title('Gender Comparison of Financial Inclusion Metrics')
                plt.xticks(x, categories, rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()

                # Calculate and display gender gaps
                gender_gap = pd.DataFrame({
                    'Category': categories,
                    'Female (%)': female_values,
                    'Male (%)': male_values,
                    'Gender Gap (M-F)': [m - f for m, f in zip(male_values, female_values)]
                })

                print("Gender gap analysis in financial inclusion:")
                display(gender_gap.sort_values('Gender Gap (M-F)', ascending=False))

    # Urban vs Rural comparison if data available
    if 'Account, rural (% age 15+)' in databank_df.columns and 'Account, urban (% age 15+)' in databank_df.columns:
        # Similar analysis for urban/rural
        if uganda_data is not None and len(uganda_data) > 0:
            recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

            location_metrics = [
                ('Account', 'Account, rural (% age 15+)', 'Account, urban (% age 15+)'),
                ('Financial institution account', 'Financial institution account, rural (% age 15+)', 'Financial institution account, urban (% age 15+)'),
                ('Mobile money account', 'Mobile money account, rural (% age 15+)', 'Mobile money account, urban (% age 15+)'),
                ('Made or received a digital payment', 'Made or received a digital payment, rural (% age 15+)', 'Made or received a digital payment, urban (% age 15+)'),
                ('Saved any money', 'Saved any money, rural (% age 15+)', 'Saved any money, urban (% age 15+)'),
                ('Borrowed any money', 'Borrowed any money, rural (% age 15+)', 'Borrowed any money, urban (% age 15+)')
            ]

            # Create data for plotting
            categories = []
            rural_values = []
            urban_values = []

            for category, rural_col, urban_col in location_metrics:
                if rural_col in recent_data and urban_col in recent_data:
                    categories.append(category)
                    rural_values.append(recent_data[rural_col])
                    urban_values.append(recent_data[urban_col])

            # Plot the urban/rural comparison
            if categories:
                plt.figure(figsize=(12, 8))

                x = np.arange(len(categories))
                width = 0.35

                plt.bar(x - width/2, rural_values, width, label='Rural')
                plt.bar(x + width/2, urban_values, width, label='Urban')

                plt.xlabel('Financial Inclusion Category')
                plt.ylabel('Percentage (%)')
                plt.title('Urban vs Rural Comparison of Financial Inclusion Metrics')
                plt.xticks(x, categories, rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()

                # Calculate and display urban-rural gaps
                location_gap = pd.DataFrame({
                    'Category': categories,
                    'Rural (%)': rural_values,
                    'Urban (%)': urban_values,
                    'Urban-Rural Gap': [u - r for u, r in zip(urban_values, rural_values)]
                })

                print("Urban-Rural gap analysis in financial inclusion:")
                display(location_gap.sort_values('Urban-Rural Gap', ascending=False))

except Exception as e:
    print(f"Error in demographic analysis: {str(e)}")

if cross_network_df is not None:
    try:
        plt.figure(figsize=(12, 6))

        # Check if required columns exist
        if all(col in cross_network_df.columns for col in ['service_providers', 'sent_transactions_percentage', 'received_transactions_percentage']):
            # Create a bar chart for sent vs received transactions
            providers = cross_network_df['service_providers'].values
            sent_pct = cross_network_df['sent_transactions_percentage'].values
            received_pct = cross_network_df['received_transactions_percentage'].values

            x = np.arange(len(providers))
            width = 0.35

            plt.bar(x - width/2, sent_pct, width, label='Sent Transactions (%)')
            plt.bar(x + width/2, received_pct, width, label='Received Transactions (%)')

            plt.xlabel('Service Providers')
            plt.ylabel('Percentage (%)')
            plt.title('Cross-Network Mobile Money Transactions by Provider')
            plt.xticks(x, providers, rotation=45, ha='right')
            plt.legend()
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing cross-network transactions: {str(e)}")

agent_services_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/agent_services.csv")

if agent_services_df is not None:
    try:
        plt.figure(figsize=(12, 8))

        # Check if required columns exist
        if all(col in agent_services_df.columns for col in ['service', 'percentage']):
            # Sort the services by percentage
            agent_services_df = agent_services_df.sort_values('percentage', ascending=True)

            # Create a horizontal bar chart
            plt.barh(agent_services_df['service'], agent_services_df['percentage'])

            plt.xlabel('Percentage (%)')
            plt.ylabel('Service')
            plt.title('Mobile Money Agent Services Offered')
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing agent services: {str(e)}")

urban_rural_payment_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/urban_rural_payment_willingness.csv")

if urban_rural_payment_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in urban_rural_payment_df.columns for col in ['location', 'sending_percentage', 'receiving_percentage']):
            # Create a grouped bar chart
            locations = urban_rural_payment_df['location'].values
            sending_pct = urban_rural_payment_df['sending_percentage'].values
            receiving_pct = urban_rural_payment_df['receiving_percentage'].values

            x = np.arange(len(locations))
            width = 0.35

            plt.bar(x - width/2, sending_pct, width, label='Willing to Pay for Sending (%)')
            plt.bar(x + width/2, receiving_pct, width, label='Willing to Pay for Receiving (%)')

            plt.xlabel('Location')
            plt.ylabel('Percentage (%)')
            plt.title('Willingness to Pay for Mobile Money Transactions by Location')
            plt.xticks(x, locations)
            plt.legend()
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing urban/rural payment willingness: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

        # Analyze digital payment adoption
        digital_payment_cols = [
            'Made or received a digital payment (% age 15+)',
            'Made a digital payment (% age 15+)',
            'Received digital payments (% age 15+)',
            'Made a digital merchant payment (% age 15+)',
            'Used a mobile phone or the internet to send money (% age 15+)',
            'Used a mobile phone or the internet to pay bills (% age 15+)',
            'Used a mobile phone or the internet to buy something online (% age 15+)'
        ]

        # Filter to columns that exist
        existing_digital_cols = [col for col in digital_payment_cols if col in recent_data.index]

        if existing_digital_cols:
            # Create labels and values for plotting
            digital_labels = [col.split(' (% age')[0] for col in existing_digital_cols]
            digital_values = [recent_data[col] for col in existing_digital_cols]

            # Sort for better visualization
            sorted_digital = sorted(zip(digital_labels, digital_values), key=lambda x: x[1], reverse=True)
            digital_labels, digital_values = zip(*sorted_digital)

            plt.figure(figsize=(12, 8))
            plt.barh(digital_labels, digital_values)
            plt.xlabel('Percentage (%)')
            plt.title('Digital Payment Adoption in Uganda')
            plt.tight_layout()
            plt.show()

        # Time series of mobile money and digital payments if we have multiple years
        if len(uganda_data) > 1:
            # Key metrics to track over time
            mobile_digital_cols = [
                'Mobile money account (% age 15+)',
                'Made or received a digital payment (% age 15+)',
                'Used a mobile phone or the internet to access an account (% age 15+)'
            ]

            # Filter to columns that exist
            existing_mobile_digital_cols = [col for col in mobile_digital_cols if col in uganda_data.columns]

            if existing_mobile_digital_cols and 'Year' in uganda_data.columns:
                plt.figure(figsize=(12, 6))

                for col in existing_mobile_digital_cols:
                    plt.plot(uganda_data['Year'], uganda_data[col], marker='o', linewidth=2, label=col.split(' (% age')[0])

                plt.title('Mobile Money and Digital Payment Trends in Uganda')
                plt.xlabel('Year')
                plt.ylabel('Percentage (%)')
                plt.legend()
                plt.grid(True, alpha=0.3)
                plt.tight_layout()
                plt.show()
except Exception as e:
    print(f"Error analyzing mobile money adoption and digital payments: {str(e)}")

transaction_methods_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/transaction_methods.csv")

if transaction_methods_df is not None:
    try:
        plt.figure(figsize=(10, 8))

        # Check if required columns exist
        if all(col in transaction_methods_df.columns for col in ['transaction_method', 'percentage']):
            # Sort the methods by percentage
            transaction_methods_df = transaction_methods_df.sort_values('percentage', ascending=False)

            # Create a pie chart
            plt.pie(transaction_methods_df['percentage'],
                   labels=transaction_methods_df['transaction_method'],
                   autopct='%1.1f%%',
                   startangle=90)
            plt.axis('equal')
            plt.title('Mobile Money Transaction Methods')
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing transaction methods: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

        # Analyze income group differences in financial inclusion
        income_metrics = [
            ('Account', 'Account, income, poorest 40% (% ages 15+)', 'Account, income, richest 60% (% ages 15+)'),
            ('Financial institution account', 'Financial institution account, income, poorest 40% (% ages 15+)', 'Financial institution account, income, richest 60% (% ages 15+)'),
            ('Mobile money account', 'Mobile money account, income, poorest 40% (% ages 15+)', 'Mobile money account, income, richest 60% (% ages 15+)'),
            ('Made or received a digital payment', 'Made or received a digital payment, income, poorest 40% (% ages 15+)', 'Made or received a digital payment, income, richest 60% (% ages 15+)'),
            ('Saved any money', 'Saved any money, income, poorest 40% (% ages 15+)', 'Saved any money, income, richest 60% (% ages 15+)'),
            ('Borrowed any money', 'Borrowed any money, income, poorest 40% (% ages 15+)', 'Borrowed any money, income, richest 60% (% ages 15+)')
        ]

        # Create data for plotting
        categories = []
        poorest_values = []
        richest_values = []

        for category, poorest_col, richest_col in income_metrics:
            if poorest_col in recent_data.index and richest_col in recent_data.index:
                categories.append(category)
                poorest_values.append(recent_data[poorest_col])
                richest_values.append(recent_data[richest_col])

        # Plot the income group comparison
        if categories:
            plt.figure(figsize=(12, 8))

            x = np.arange(len(categories))
            width = 0.35

            plt.bar(x - width/2, poorest_values, width, label='Poorest 40%')
            plt.bar(x + width/2, richest_values, width, label='Richest 60%')

            plt.xlabel('Financial Inclusion Category')
            plt.ylabel('Percentage (%)')
            plt.title('Income Group Comparison of Financial Inclusion Metrics')
            plt.xticks(x, categories, rotation=45, ha='right')
            plt.legend()
            plt.tight_layout()
            plt.show()

            # Calculate and display income group gaps
            income_gap = pd.DataFrame({
                'Category': categories,
                'Poorest 40% (%)': poorest_values,
                'Richest 60% (%)': richest_values,
                'Income Gap (R-P)': [r - p for r, p in zip(richest_values, poorest_values)]
            })

            print("Income gap analysis in financial inclusion:")
            display(income_gap.sort_values('Income Gap (R-P)', ascending=False))
except Exception as e:
    print(f"Error analyzing income groups and financial inclusion: {str(e)}")

end_user_income_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/end_user_income.csv")

if end_user_income_df is not None:
    try:
        plt.figure(figsize=(12, 8))

        # Check if required columns exist
        if all(col in end_user_income_df.columns for col in ['monthly_income_range', 'total_percentage']):
            # Create a bar chart of income distribution
            plt.bar(end_user_income_df['monthly_income_range'], end_user_income_df['total_percentage'])

            plt.xlabel('Monthly Income Range')
            plt.ylabel('Percentage (%)')
            plt.title('Income Distribution of Mobile Money Users')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()

            # If gender breakdown available, create a grouped bar chart
            if all(col in end_user_income_df.columns for col in ['male_percentage', 'female_percentage']):
                plt.figure(figsize=(12, 8))

                x = np.arange(len(end_user_income_df['monthly_income_range']))
                width = 0.35

                plt.bar(x - width/2, end_user_income_df['male_percentage'], width, label='Male')
                plt.bar(x + width/2, end_user_income_df['female_percentage'], width, label='Female')

                plt.xlabel('Monthly Income Range')
                plt.ylabel('Percentage (%)')
                plt.title('Income Distribution by Gender of Mobile Money Users')
                plt.xticks(x, end_user_income_df['monthly_income_range'], rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()
    except Exception as e:
        print(f"Error analyzing end user income: {str(e)}")

poverty_df = load_and_examine_file(f"{DATA_PATH}UBoS/Distribution_of_Poverty_in_Uganda_across_regions_2016_17.xlsx")

if poverty_df is not None:
    try:
        # Attempt to reshape the data for analysis if needed
        # Since we don't know the exact structure, this is a template

        # Example: Create a bar chart of poverty rates by region
        plt.figure(figsize=(12, 6))

        # Assuming poverty_df has 'Region' and 'Poverty_Rate' columns
        if 'Region' in poverty_df.columns and 'Poverty_Rate' in poverty_df.columns:
            # Sort regions by poverty rate
            poverty_df = poverty_df.sort_values('Poverty_Rate', ascending=False)

            plt.bar(poverty_df['Region'], poverty_df['Poverty_Rate'])
            plt.xlabel('Region')
            plt.ylabel('Poverty Rate (%)')
            plt.title('Poverty Rates by Region in Uganda')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()
        else:
            print("Poverty dataframe does not have expected columns format. Manual analysis needed.")
    except Exception as e:
        print(f"Error analyzing regional poverty data: {str(e)}")

try:
    # This would depend on the structure of your agent_demographics_df
    if agent_demographics_df is not None and 'region' in agent_demographics_df.columns.str.lower():
        region_col = agent_demographics_df.columns[agent_demographics_df.columns.str.lower() == 'region'][0]
        percentage_col = [col for col in agent_demographics_df.columns if 'percentage' in col.lower()][0]

        if percentage_col:
            plt.figure(figsize=(12, 6))

            # Group by region and calculate percentages
            region_data = agent_demographics_df[agent_demographics_df['demographic_category'] == 'Region']

            plt.bar(region_data['segment'], region_data[percentage_col])
            plt.xlabel('Region')
            plt.ylabel('Percentage (%)')
            plt.title('Mobile Money Agent Distribution by Region')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()
    else:
        print("No regional data available in the agent demographics dataset.")
except Exception as e:
    print(f"Error analyzing regional agent distribution: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

        # Analyze education level differences in financial inclusion
        education_metrics = [
            ('Account', 'Account, primary education or less (% ages 15+)', 'Account, secondary education or more (% ages 15+)'),
            ('Financial institution account', 'Financial institution account, primary education or less (% ages 15+)', 'Financial institution account, secondary education or more (% ages 15+)'),
            ('Mobile money account', 'Mobile money account, primary education or less (% ages 15+)', 'Mobile money account, secondary education or more (% ages 15+)'),
            ('Made or received a digital payment', 'Made or received a digital payment, primary education or less (% ages 15+)', 'Made or received a digital payment, secondary education or more (% ages 15+)'),
            ('Saved any money', 'Saved any money, primary education or less (% ages 15+)', 'Saved any money, secondary education or more (% ages 15+)'),
            ('Borrowed any money', 'Borrowed any money, primary education or less (% ages 15+)', 'Borrowed any money, secondary education or more (% ages 15+)')
        ]

        # Create data for plotting
        categories = []
        primary_values = []
        secondary_values = []

        for category, primary_col, secondary_col in education_metrics:
            if primary_col in recent_data.index and secondary_col in recent_data.index:
                categories.append(category)
                primary_values.append(recent_data[primary_col])
                secondary_values.append(recent_data[secondary_col])

        # Plot the education level comparison
        if categories:
            plt.figure(figsize=(12, 8))

            x = np.arange(len(categories))
            width = 0.35

            plt.bar(x - width/2, primary_values, width, label='Primary Education or Less')
            plt.bar(x + width/2, secondary_values, width, label='Secondary Education or More')

            plt.xlabel('Financial Inclusion Category')
            plt.ylabel('Percentage (%)')
            plt.title('Education Level Comparison of Financial Inclusion Metrics')
            plt.xticks(x, categories, rotation=45, ha='right')
            plt.legend()
            plt.tight_layout()
            plt.show()

            # Calculate and display education level gaps
            education_gap = pd.DataFrame({
                'Category': categories,
                'Primary Edu or Less (%)': primary_values,
                'Secondary Edu or More (%)': secondary_values,
                'Education Gap (S-P)': [s - p for s, p in zip(secondary_values, primary_values)]
            })

            print("Education gap analysis in financial inclusion:")
            display(education_gap.sort_values('Education Gap (S-P)', ascending=False))
except Exception as e:
    print(f"Error analyzing education levels and financial inclusion: {str(e)}")

# Agent education level analysis
agent_education_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/agent_education.csv")

if agent_education_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in agent_education_df.columns for col in ['education_level', 'percentage']):
            # Create a pie chart of education levels
            plt.pie(agent_education_df['percentage'],
                   labels=agent_education_df['education_level'],
                   autopct='%1.1f%%',
                   startangle=90)
            plt.axis('equal')
            plt.title('Education Levels of Mobile Money Agents')
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing agent education levels: {str(e)}")

end_user_education_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/end_user_education.csv")

if end_user_education_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in end_user_education_df.columns for col in ['education_level', 'total_percentage']):
            # Create a pie chart of education levels
            plt.pie(end_user_education_df['total_percentage'],
                   labels=end_user_education_df['education_level'],
                   autopct='%1.1f%%',
                   startangle=90)
            plt.axis('equal')
            plt.title('Education Levels of Mobile Money Users')
            plt.tight_layout()
            plt.show()

            # If gender breakdown available, create a grouped bar chart
            if all(col in end_user_education_df.columns for col in ['male_percentage', 'female_percentage']):
                plt.figure(figsize=(12, 8))

                x = np.arange(len(end_user_education_df['education_level']))
                width = 0.35

                plt.bar(x - width/2, end_user_education_df['male_percentage'], width, label='Male')
                plt.bar(x + width/2, end_user_education_df['female_percentage'], width, label='Female')

                plt.xlabel('Education Level')
                plt.ylabel('Percentage (%)')
                plt.title('Education Levels by Gender of Mobile Money Users')
                plt.xticks(x, end_user_education_df['education_level'], rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()
    except Exception as e:
        print(f"Error analyzing end user education levels: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

        # COVID-19 financial hardship analysis
        covid_cols = [
            'Experience or continue to experience severe financial hardship as a result of the disruption caused by COVID-19: not worried (% age 15+)',
            'Experience or continue to experience severe financial hardship as a result of the disruption caused by COVID-19: somewhat worried (% age 15+)',
            'Experience or continue to experience severe financial hardship as a result of the disruption caused by COVID-19: very worried (% age 15+)'
        ]

        # Filter to columns that exist
        existing_covid_cols = [col for col in covid_cols if col in recent_data.index]

        if existing_covid_cols:
            # Create labels and values for plotting
            covid_labels = [col.split(': ')[1].split(' (% age')[0] for col in existing_covid_cols]
            covid_values = [recent_data[col] for col in existing_covid_cols]

            plt.figure(figsize=(10, 6))
            plt.pie(covid_values, labels=covid_labels, autopct='%1.1f%%', startangle=90)
            plt.axis('equal')
            plt.title('Worry About Financial Hardship Due to COVID-19')
            plt.tight_layout()
            plt.show()

        # COVID-19 impact on digital payments
        covid_payment_cols = [
            'Made a digital in-store merchant payment for the first time after COVID-19 started (% age 15+)',
            'Made a digital online payment for an online purchase for the first time after COVID-19 started (% age 15+)',
            'Made a digital merchant payment for the first time after COVID-19 started (% age 15+)',
            'Made a utility payment: using an account for the first time after COVID-19 started (% age 15+)'
        ]

        # Filter to columns that exist
        existing_covid_payment_cols = [col for col in covid_payment_cols if col in recent_data.index]

        if existing_covid_payment_cols:
            # Create labels and values for plotting
            covid_payment_labels = [col.split(' for the first time after COVID-19 started')[0] for col in existing_covid_payment_cols]
            covid_payment_values = [recent_data[col] for col in existing_covid_payment_cols]

            plt.figure(figsize=(12, 6))
            plt.bar(covid_payment_labels, covid_payment_values)
            plt.xlabel('Digital Payment Type')
            plt.ylabel('Percentage (%)')
            plt.title('Digital Payments Used for the First Time After COVID-19 Started')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()
except Exception as e:
    print(f"Error analyzing COVID-19 impact on financial behaviors: {str(e)}")

agent_business_age_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/agent_business_age.csv")

if agent_business_age_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in agent_business_age_df.columns for col in ['duration', 'total_percentage']):
            # Create a bar chart of business age
            plt.bar(agent_business_age_df['duration'], agent_business_age_df['total_percentage'])

            plt.xlabel('Business Age')
            plt.ylabel('Percentage (%)')
            plt.title('Age of Mobile Money Agent Businesses')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()

            # If urban/rural breakdown available, create a grouped bar chart
            if all(col in agent_business_age_df.columns for col in ['urban_percentage', 'rural_percentage']):
                plt.figure(figsize=(12, 8))

                x = np.arange(len(agent_business_age_df['duration']))
                width = 0.35

                plt.bar(x - width/2, agent_business_age_df['urban_percentage'], width, label='Urban')
                plt.bar(x + width/2, agent_business_age_df['rural_percentage'], width, label='Rural')

                plt.xlabel('Business Age')
                plt.ylabel('Percentage (%)')
                plt.title('Age of Mobile Money Agent Businesses by Location')
                plt.xticks(x, agent_business_age_df['duration'], rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()
    except Exception as e:
        print(f"Error analyzing agent business age: {str(e)}")

# Customer volume analysis
customer_volume_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/customer_volume.csv")

if customer_volume_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in customer_volume_df.columns for col in ['customers_served_daily', 'overall_percentage']):
            # Create a bar chart of customer volume
            plt.bar(customer_volume_df['customers_served_daily'], customer_volume_df['overall_percentage'])

            plt.xlabel('Customers Served Daily')
            plt.ylabel('Percentage of Agents (%)')
            plt.title('Daily Customer Volume for Mobile Money Agents')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()

            # If urban/rural breakdown available, create a grouped bar chart
            if all(col in customer_volume_df.columns for col in ['urban_percentage', 'rural_percentage']):
                plt.figure(figsize=(12, 8))

                x = np.arange(len(customer_volume_df['customers_served_daily']))
                width = 0.35

                plt.bar(x - width/2, customer_volume_df['urban_percentage'], width, label='Urban')
                plt.bar(x + width/2, customer_volume_df['rural_percentage'], width, label='Rural')

                plt.xlabel('Customers Served Daily')
                plt.ylabel('Percentage of Agents (%)')
                plt.title('Daily Customer Volume for Mobile Money Agents by Location')
                plt.xticks(x, customer_volume_df['customers_served_daily'], rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()
    except Exception as e:
        print(f"Error analyzing customer volume: {str(e)}")

# Float replenishment analysis
float_replenishment_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/float_replenishment.csv")

if float_replenishment_df is not None:
    try:
        plt.figure(figsize=(10, 6))

        # Check if required columns exist
        if all(col in float_replenishment_df.columns for col in ['replenishment_method', 'total_percentage']):
            # Create a pie chart of replenishment methods
            plt.pie(float_replenishment_df['total_percentage'],
                   labels=float_replenishment_df['replenishment_method'],
                   autopct='%1.1f%%',
                   startangle=90)
            plt.axis('equal')
            plt.title('Mobile Money Agent Float Replenishment Methods')
            plt.tight_layout()
            plt.show()

            # If urban/rural breakdown available, create a grouped bar chart
            if all(col in float_replenishment_df.columns for col in ['urban_percentage', 'rural_percentage']):
                plt.figure(figsize=(12, 8))

                x = np.arange(len(float_replenishment_df['replenishment_method']))
                width = 0.35

                plt.bar(x - width/2, float_replenishment_df['urban_percentage'], width, label='Urban')
                plt.bar(x + width/2, float_replenishment_df['rural_percentage'], width, label='Rural')

                plt.xlabel('Replenishment Method')
                plt.ylabel('Percentage of Agents (%)')
                plt.title('Mobile Money Agent Float Replenishment Methods by Location')
                plt.xticks(x, float_replenishment_df['replenishment_method'], rotation=45, ha='right')
                plt.legend()
                plt.tight_layout()
                plt.show()
    except Exception as e:
        print(f"Error analyzing float replenishment methods: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        # Select key financial inclusion indicators
        key_indicators = [
            'Account (% age 15+)',
            'Financial institution account (% age 15+)',
            'Mobile money account (% age 15+)',
            'Made or received a digital payment (% age 15+)',
            'Own a mobile phone (% age 15+)',
            'Saved any money (% age 15+)',
            'Borrowed any money (% age 15+)',
            'Saved at a financial institution (% age 15+)',
            'Saved money using a mobile money account (% age 15+)',
            'Has access to the internet (% age 15+)'
        ]

        # Filter to indicators that exist in the data
        existing_indicators = [col for col in key_indicators if col in uganda_data.columns]

        if existing_indicators and len(existing_indicators) > 1:
            # Create correlation matrix
            corr_matrix = create_correlation_heatmap(
                uganda_data,
                cols=existing_indicators,
                title="Correlation Between Financial Inclusion Indicators in Uganda"
            )

            # Display the correlation values for reference
            print("Correlation matrix for key financial inclusion indicators:")
            display(corr_matrix)

            # If we have data across multiple countries, we can also analyze global correlations
            if 'Country name' in databank_df.columns and len(databank_df['Country name'].unique()) > 1:
                # Select the most recent year data for each country
                recent_year = databank_df['Year'].max()
                global_recent_data = databank_df[databank_df['Year'] == recent_year]

                # Filter to indicators that exist in the global data
                global_existing_indicators = [col for col in key_indicators if col in global_recent_data.columns]

                if global_existing_indicators and len(global_existing_indicators) > 1:
                    # Create correlation matrix for global data
                    global_corr_matrix = create_correlation_heatmap(
                        global_recent_data,
                        cols=global_existing_indicators,
                        title="Global Correlation Between Financial Inclusion Indicators"
                    )

                    # Display the global correlation values for reference
                    print("Global correlation matrix for key financial inclusion indicators:")
                    display(global_corr_matrix)
except Exception as e:
    print(f"Error creating correlation analysis: {str(e)}")

replenishment_challenges_df = load_and_examine_file(f"{DATA_PATH}Interopperability-in-Mobile-Financial-Services-Final-Report/replenishment_challenges.csv")

if replenishment_challenges_df is not None:
    try:
        plt.figure(figsize=(12, 6))

        # Check if required columns exist
        if all(col in replenishment_challenges_df.columns for col in ['challenge', 'percentage']):
            # Sort the challenges by percentage
            replenishment_challenges_df = replenishment_challenges_df.sort_values('percentage', ascending=False)

            # Create a bar chart
            plt.bar(replenishment_challenges_df['challenge'], replenishment_challenges_df['percentage'])

            plt.xlabel('Challenge')
            plt.ylabel('Percentage (%)')
            plt.title('Mobile Money Agent Replenishment Challenges')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()
    except Exception as e:
        print(f"Error analyzing agent replenishment challenges: {str(e)}")

try:
    if uganda_data is not None and len(uganda_data) > 0:
        recent_data = uganda_data.sort_values('Year', ascending=False).iloc[0].copy()

        # Analyze emergency fund access
        emergency_fund_cols = [
            'Coming up with emergency funds in 30 days: possible and not difficult at all (% age 15+)',
            'Coming up with emergency funds in 30 days: possible and somewhat difficult (% age 15+)',
            'Coming up with emergency funds in 30 days: possible and very difficult (% age 15+)',
            'Coming up with emergency funds in 30 days: not possible (% age 15+)'
        ]

        # Filter to columns that exist
        existing_emergency_cols = [col for col in emergency_fund_cols if col in recent_data.index]

        if existing_emergency_cols:
            # Create labels and values for plotting
            emergency_labels = [col.split('Coming up with emergency funds in 30 days: ')[1].split(' (% age')[0] for col in existing_emergency_cols]
            emergency_values = [recent_data[col] for col in existing_emergency_cols]

            plt.figure(figsize=(10, 6))
            plt.pie(emergency_values, labels=emergency_labels, autopct='%1.1f%%', startangle=90)
            plt.axis('equal')
            plt.title('Ability to Come Up with Emergency Funds in Uganda')
            plt.tight_layout()
            plt.show()

        # Analyze financial worries
        worry_columns = [
            'Most worrying financial issue: money for old age (% age 15+)',
            'Most worrying financial issue: paying for medical costs in case of a serious illness or accident (% age 15+)',
            'Most worrying financial issue: money to pay for monthly expenses or bills (% age 15+)',
            'Most worrying financial issue: paying school or education fees (% age 15+)'
        ]

        # Filter to columns that exist
        existing_worry_cols = [col for col in worry_columns if col in recent_data.index]

        if existing_worry_cols:
            # Create labels and values for plotting
            worry_labels = [col.split('Most worrying financial issue: ')[1].split(' (% age')[0] for col in existing_worry_cols]
            worry_values = [recent_data[col] for col in existing_worry_cols]

            plt.figure(figsize=(10, 6))
            plt.pie(worry_values, labels=worry_labels, autopct='%1.1f%%', startangle=90)
            plt.axis('equal')
            plt.title('Most Worrying Financial Issues in Uganda')
            plt.tight_layout()
            plt.show()

        # Analyze saving behaviors
        saving_columns = [
            'Saved any money (% age 15+)',
            'Saved at a financial institution (% age 15+)',
            'Saved using a savings club or a person outside the family (% age 15+)',
            'Saved money using a mobile money account (% age 15+)',
            'Saved for old age (% age 15+)',
            'Saved for education or school fees (% age 15+)',
            'Saved to start, operate, or expand a farm or business (% age 15+)'
        ]

        # Filter to columns that exist
        existing_saving_cols = [col for col in saving_columns if col in recent_data.index]

        if existing_saving_cols:
            # Create labels and values for plotting
            saving_labels = [col.split('Saved ')[1].split(' (% age')[0] for col in existing_saving_cols]
            saving_values = [recent_data[col] for col in existing_saving_cols]

            # Sort for better visualization
            sorted_savings = sorted(zip(saving_labels, saving_values), key=lambda x: x[1], reverse=True)
            saving_labels, saving_values = zip(*sorted_savings)

            plt.figure(figsize=(12, 8))
            plt.barh(saving_labels, saving_values)
            plt.xlabel('Percentage (%)')
            plt.title('Saving Behaviors in Uganda')
            plt.tight_layout()
            plt.show()
except Exception as e:
    print(f"Error analyzing financial behaviors and worries: {str(e)}")